#import "../thesis-base.typ": *
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#import "@preview/curryst:0.5.1": rule, prooftree
#import "@preview/diagraph:0.3.3": *

#show: codly-init.with()
#codly(languages: codly-languages, breakable: true)

#show figure.where(kind: raw): it => [
  #show raw.where(lang: "DSL"): it_r => [
    #show regex("\b(object|func|var|return|if|else|intrinsic|new|true|false|package|import|)\b") : keyword => text(weight: "bold", fill: blue, keyword)
    #show regex("\".+\"") : keyword => text(fill: rgb("#067D17"), keyword)
    #show regex("/\*.+\*/") : keyword => text(fill: rgb("#6d6d6d"), keyword)
    #it_r
  ]

  #it
]

#chapter(3, "Разработка и реализация языка и транслятора")

== Описание DSL

Данный раздел содержит описание синтаксиса и семантики разрабатываемого языка. Каждый из подразделов посвящён конкретной языковой возможности и приводит, при необходимости, синтаксическое, семантическое описание, а также правила типизации. 

Правила описания синтаксиса представлены в форме, похожей на BNF. В них в угловых скобках указаны имена правил, знак `?` указывает на опциональность терма, `*` указывает произвольное количество повторений терма, `+` указывает, что терм может повторяться больше одного раза, а `|` используется как разделитель между правилами в случае, когда применимо любое из списка. Токены, указанные без угловых скобок или в двойных кавычках, обозначают себя.



=== Объявления верхнего уровня

Объявления верхнего уровня описывают структуру файла с кодом на разрабатываемом языке. Он состоит из опционального указания имени пакета, за которым идёт произвольное число верхоуровневых объявлений. Соответствующие синтаксические правила приведены на Рисунке @syntax-top-level.

#syntax-rule(
  "Синтаксические правила структуры файла",
  "syntax-top-level"
)[
```
<file>         ::= 
                <packageDecl>? <topLevelDecl>*;

<topLevelDecl> ::=
                ...
```
]

Правило _\<file\>_ описывает структуру всего файла с кодом на разрабатываемом DSL. Правило _\<topLevelDecl\>_ содержит в себе все определения для верхоуровневых сущностей. Они будут рассмотрены далее.

=== Пакеты

Пакеты (ключевое слово _package_) позволяют определить имя пакета в описываемой библиотеке. Они могут быть использованы для импортирования (ключевое слово _import_). Соответствующие синтаксические правила приведены на Рисунке @syntax-packages.

#syntax-rule(
  "Синтаксические правила объявления и подключения пакетов",
  "syntax-packages"
)[
```
<packageDecl>  ::=
                package <string> ";";
       
<topLevelDecl> ::=
                ...
                | import <string> ";"   
                ...
```
]

Объявление пакета является опциональным. Если оно не указано, оно будет установлено на основе имени файла. Это поведение было оставлено для сохранения совместимости со старым механизмом модулей в расширениях PT JSA. Из синтаксических правил на Рисунке @syntax-packages следует, что не допускается больше одного такого объявление, а также то что оно должно быть первым. 

=== Объекты

Объекты используются для моделирования таких сущностей библиотек как классы, объекты и структуры. Синтаксические правила приведены на Рисунке @syntax-obj.

#syntax-rule(
  "Синтаксические правила для функций",
  "syntax-obj"
)[
```
<topLevelDecl> ::=
                ...
                | <objectDecl>
                ...
         
<objectDecl>   ::= 
             <annotation>* 'object' <ID> '{' <objectBody> '}';

<objectBody>   ::= 
                <objectBodyStatement>*;

<objectBodyStatement> ::=
                       ...
```
]

Объекты являются контейнерами для функций и полей, которые будут рассмотрены далее.

=== Функции

Функции в DSL позволяют описывать сигнатуру и поведение функций из описываемого кода. Их синтаксические правила представлены на Рисунке @syntax-func.

#syntax-rule(
  "Синтаксические правила для функций",
  "syntax-func"
)[
```
<topLevelDecl> ::=
                ...
                | <funcDecl>
                ...

                
<funcDecl>   ::=
        <annotation>* 
        'intrinsic'? 'func' <ID> generic? '(' <args> ')' (':' <ID>)? 
        ('{' <statementsBlock> '}')?;

<generic>    ::=
              '<' <ID> (',' <ID>)* ','? '>';

<args>       ::=
              <arg>? (',' <arg>)* ','?;

<arg>        ::=
              <ID> (':' <ID>) ('=' <expression>)?;
              

<statementsBlock> ::=
                   <statement>*;

<statement>       ::=
                   ...
                   | return <expression>?
                   ...
```
]

Определение функции содержит её имя, список аргументов (возможно, пустой), опциональный возвращаемый тип и тело. В случае отсутствия указания возвращаемого типа, предполагается неявный тип _none_, обозначающий, что функция не возвращает значение. Поддерживается указание значений по-умолчанию у аргументов.

Модификатор `intrinsic` позволяет описывать внутренние функции. Они не содержат тела, а также могут объявлять типовые параметры (`generics`). Это необходимо для:
- специальной поддержки некоторых функций в трансляторе;
- возможности реализации функций на языке C\# Scripting.

Типовые параметры позволяют писать обобщённый код с учётом неизвестных при определении функции типов. В настоящее время их можно объявить только у внутренних функций, использовать у их аргументов, а также передать конкретный тип при вызове. 


Механизм внутренних функций описан подробнее в разделе @c-sharp-interop.

// Правила типизации приведены на Рисунке @types-func-decl.

// #type-rule(
//   "Некоторые правила типизации объявлений функции",
//   "types-func-decl"
// )[
//   #prooftree([])
//   #prooftree(
//     rule(
//       name: "T-FuncDecl",
//       [$Gamma tack (f(a_1: T_1, ... a_n:T_n): T_r) => Gamma, f : (T_1, ..., T_n) -> T_r $],

//     )
//   )
//   #prooftree([])
//   #prooftree(
//     rule(
//       name: "T-FuncDeclImplicitNone",
//       [$Gamma tack (f(a_1: T_1, ... a_n:T_n)) => Gamma, f : (T_1, ..., T_n) -> "none" $],

//     )
//   )
// ]

// Поддерживается указание значений по-умолчанию у аргументов. Правила типизации для этого случая приведены на Рисунке @types-func-decl-args.

// #type-rule(
//   "Правила типизации для значений аргументов функции по-умолчанию",
//   "types-func-decl-args"
// )[
//   #prooftree([])
//   #prooftree(
//     rule(
//       name: "T-FuncArgDefaultValue",
//       [$Gamma tack a:T = v$],
//       [$Gamma tack v : T$]
//     )
//   )
// ]


Возврат значения из функции осуществляется оператором `return`. Допускается наличие нескольких операторов возврата в одной функции. Пример такой функции приведён в Листинге @example-return

#figure(
  caption: "Пример функции с возвращением результата",
```DSL
func minOf(a: int, b: int): int {
  if (a < b) {
    return a;
  }
  return b;
}
```
) <example-return>


=== Объявление переменных

Синтаксис для определения новой переменной приведён на Рисунке @syntax-vars.

#syntax-rule(
  "Синтаксические правила для объявления переменной",
  "syntax-vars"
)[
```
<topLevelDecl>  ::=
                 ...
                 | <varDecl> ';'
                 ...

<objectBodyStatement> ::=
                       ...
                       | <varDecl> ';'
                       ...

<statement> ::=
             ...
             | <varDecl> ';'
             ...

<varDecl>   ::=
             'var' ID (':' ID)? ('=' expression);
```
]

Из этих правил следует, что объявления переменных могут быть на верхнем уровне, на уровне объекта (поля) и внутри тел функций. Допускается отсутствие указания типа. В этом случае оно будет выведено на основании типа инициализирующего выражения. Допускается отсутствие этого выражения, в этом случае переменная будет непроинициализирована при объявлении. Отсутствие типа и значения при инициализации не допускается. Обработка чтения значения из этой переменной зависит от анализатора.

Запрещается переопределять переменные (_variables shadowing_), неизменяемые переменные отсутствуют для упрощения языка и транслятора. 

=== Выражения 

Разрабатываемый DSL поддерживает арифметические, строковые и булевы выражения. Также поддерживается вызов функций, инстанциирование экземпляров класса, использование переменных и чтение значений полей. Синтаксические правила для выражений приведены на Рисунке @syntax-expr.

#syntax-rule(
  "Синтаксические правила для выражений",
  "syntax-expr"
)[
```
<expression> ::=
        <functionCall>
      | '(' <expression> ')'
      | <expression> ('*' | '/') <expression>
      | <expression> '%' <expression>
      | <expression> ('+' | '-') <expression>
      | ('-' | '+') <expression>
      | <expression>('=='|'!='|'<='|'<'|'>='|'>') <expression>
      | <expressionAtomic>
      ;

<expressionAtomic> ::=
        <primitiveLiteral>
      | <newExpression>
      | <variableExpression>
      | <qualifiedExpression>
      ;

<primitiveLiteral> ::=
        <intLiteral>
      | <floatLiteral>
      | <stringLiteral>
      | <boolLiteral>

newExpression ::=
    'new' <ID> '(' <expression>? (',' <expression>)+ ','? ')';

variableExpression ::=
                    <ID>;

qualifiedAccess    ::=
                    (<ID> '.')* <ID>;
```
]

В Листинге @example-expressions приведен пример использования выражений.

#show figure: set block(breakable: false)
#figure(
  caption: "Пример использования выражений",
```DSL
func buildClient(host: string, port: int): HttpClient {
  var hostWithSchema = "https://" + host;
  return new HttpClient(
    /*port*/ minOf(1024, port),
    /*host*/ hostWithSchema,
  )
}
```
) <example-expressions>
#show figure: set block(breakable: true)


Некоторые правила типизации приведены на Рисунке @types-expr. Для этого используется способ, похожий на представленный в @tapl.

#show figure: set block(breakable: false)
#type-rule(
  "Некоторые правила типизации выражений",
  "types-expr"
)[
  #prooftree(
    rule(
      name: "T-BinExpr",
      [$Gamma tack v_1 plus.circle v_2 : T, "где" plus.circle in {*, \/, %, +, -}$],
      [$Gamma tack v_1 : T$],
      [$Gamma tack v_2 : T$]
    )
  )
  #prooftree([])
  #prooftree(
    rule(
      name: "T-Not",
      [$Gamma tack !v : "Bool"$],
      [$Gamma tack v : "Bool"$],
    )
  )
  #prooftree([])
  #prooftree(
    rule(
      name: "T-Rel",
      [$Gamma tack v_1 space R space v_2 : "Bool", "где" R in {"==", "!=", ">", "<", ">=", "<="} $],
      [$Gamma tack v_1 : T$],
      [$Gamma tack v_2 : T$],
    )
  )
  #prooftree([])
  #prooftree(
    rule(
      name: "T-Var",
      [$Gamma tack v : T$],
      [$v : T in Gamma$],
    )
  )

  #prooftree([])
  #prooftree(
    rule(
      name: "T-FuncApp",
      [$Gamma tack (f(v_1, ..., v_n)) : T$],
      [$Gamma tack f : (T_1, ... T_n) -> T$],
      [$Gamma tack v_1 : T_1$],
      [...],
      [$Gamma tack v_n : T_n$]
    )
  )
]

#show figure: set block(breakable: false)

=== Присваивание значение

Присваивание значений осуществляется с помощью оператора _=_. Оно позволяет присваивать значения для полей и переменных. Синтаксические правила приведены на Рисунке @syntax-assignment.

#syntax-rule(
  "Синтаксические правила присваения значения",
  "syntax-assignment"
)[
```
<statement> ::= 
             ...
             | <assignment>
             ...

<assignment> ::=
              <expression> '=' <expression>;
```
]

Можно заметить, что в правиле _\<assignment\>_ слева от токена '=' указано правило _\<expression\>_. Таким образом, синтаксически верно присваивание нового значения совершенно любым выражениям, даже таким, как инстанциирование нового объекта, вызов функции. Обработка таких случаев как ошибок осуществляется на этапе семантического анализа в процессе трансляции. Такое решение позволяет значительно облегчить код грамматики языка.

В Листинге @example-assignment приведен пример использования операторов присваивания.

#figure(
  caption: "Пример использования операций присваивания",
```DSL
object HttpClient {
  var port: int;
  var base_url: string;

  func __init__(port: int, base_url: string) {
    self.port = port;
    self.base_url = base_url;
  }
}
```
) <example-assignment>

=== Оператор условного ветвления

Оператор условного ветвления позволяет описать нелинейное поведение описываемого кода. Синтаксис ветвлений приведён на Рисунке @syntax-if. У ветвления, как и во многих популярных языках программирования, есть условие, тип которого должен быть _Bool_, основное тело, а также альтернативная ветка, которая также может содержать условное ветвление.

Для упрощения языка в рамках прототипа было принято решение отказаться от концепции использование условных ветвлений в качестве выражений.

#syntax-rule(
  "Синтаксические правила условного ветвления",
  "syntax-if"
)[
```
<statement> ::= 
             ...
             | <ifStatement>
             ...

<ifStatement> ::=
               'if' '(' <expression> ')' 
               '{' <statementsBlock> '}' 
               (
                 ('else' <ifStatement>) 
                 | 'else' '{' <statementsBlock> '}'
               )?
```
]



=== Аннотации <chapter-anno>

Аннотации позволяют изменять поведение транслятора для некоторых сущностей в коде. Их можно применять к объявлению объекта или функции. Синтаксические правила представлены на Рисунке @syntax-annotation. 

#syntax-rule(
  "Синтаксическое правило для аннотации",
  "syntax-annotation"
)[
```
<annotation> ::=
                  '@' <ID> '(' <expressionList> ')';

<expressionList> ::=
                  <expression> (',' <expression>)* ',';
```
]

Пример использования аннотации приведён на Рисунке @example-annotation. Сейчас реализована поддержка только для одной аннотации `@GeneratedName`. Оно позволяет задать имя переменной, которая будет использована в сгенерированном коде. Это необходимо для обеспечения возможности частичного написания кода расширения на низкоуровневом коде на языке C\# Script. Дело в том, что при трансляции применяется намеренное искажение имён (_name mangling_) для избежания коллизий. Подробнее эта концепция была описана в @kefallonitis2007name.

#figure(
  caption: "Пример использования аннотации @GeneratedName",
)[
```DSL
@GeneratedName
object Obj {
  ...
}
```
] <example-annotation>


=== Совместимость с кодом на C\# Script <c-sharp-interop>

В силу того, что уже есть набор расширений, написанных на языке C\# Script, а также ограничений текущей реализации DSL, важным аспектом разрабатываемых технологий является совместимость между языком и C\# Script. На уровне языка, она обеспечивается двумя механизмами: `intrinsic`-функциями и аннотацией `@GeneratedName` (см. раздел @chapter-anno). Вторая часть поддержки реализована в трансляторе. При обнаружении им файлов с расширением `.jsa` (файлы старых расширений) с именем, совпадающим с именем файла на DSL, содержимое специальным образом будет добавлено в результирующий файл трансляции. В нём можно использовать имена сущностей из DSL с аннотацией `@GeneratedName`.

Внутренние (`intrinsic`) функции позволяют описать сигнатуру на DSL, а её реализацию на языке C\# Script. Пример сигнатуры функции приведён в Листинге @example-as-dsl-sig, а её реализации в Листинге @example-as-dsl-impl. Она позволяет делать приведение типов. Так как с точки зрения расширений на языке C\# Script семантических типов не существует, они заменяются на тип символьного выражения `SymbolicExpression`. Таким образом, код, использующий функцию `As` в DSL остаётся типизированным, а в реализации функция превращается в функцию идентичности. По соглашению, во все функции на целевом языке добавляется аргумент типа `Location`, который повсеместно используется в PT JSA. Это значение автоматически передаётся транслятором. В дальнейшем планируется добавить специальные аннотации, которые позволят изменить это поведение.

#figure(
  caption: "Пример сигнатуры внутренней функции",
)[
  ```DSL
  intrinsic func As<TResult>(expression: any): TResult
  ```
] <example-as-dsl-sig>

#figure(
  caption: "Пример реализации внутренней функции",
)[
  ```csharp
  SymbolicExpression As(
    Location location, 
    SymbolicExpression expression)
  {
    return expression;
  }
  ```
] <example-as-dsl-impl>

=== Стандартная библиотека

Стандартная библиотека языка содержит операции для работы с taint-данными. В настоящее время она содержит только `intrinsic`-функции, приведённые в Листинге @default-library. 

#figure(
  caption: "Код стандартной библиотеки на разрабатываемом языке"
)[
```DSL
package "Standard";

intrinsic func Detect(
  expression: any, 
  vulnerabilityType: string, 
  grammar: string)

intrinsic func WithTaintMark<T>(
  expression: T, 
  taintOrigin: string): T

intrinsic func CreateTaintedDataOfType<T>(
  taintOrigin: string): T

intrinsic func CreateDataOfType<T>(): T

intrinsic func WithoutVulnerability<T>(
  expression: T, 
  vulnerabilityType: string): T

intrinsic func GetTaintOrigin(
  expression: any): string

intrinsic func As<TResult>(
  expression: any): TResult
```
] <default-library>

Рассмотрим функцию `WithTaintMark`. Она позволяет получить копию выражения, но с добавленной taint-меткой, указывающей её место происхождения (`origin`). Оно используется в PT JSA для обнаружения уязвимостей, а также генерации кода для эксплуатации уязвимости. Обычно, им является код для HTTP-запроса. Эта функция позволяет описывать данные, порождённые источником (_sink_). Реализация функции `WithTaintMark` приведена в Листинге @example-WithTaintMark.

#figure(
  caption: "Реализация функции WithTaintMark"
)[
```csharp
TExpr WithTaintMark<TExpr>(
  Location location, 
  TExpr? expression, 
  string origin) where TExpr : SymbolicExpression
{
  if (expression == null) {
	  return null;
  }
  var taintOrigin = new TaintOrigin(origin);
  return expression.With(taintOrigin);
}
```
]<example-WithTaintMark>

В Таблице @standard-lib-table приведено описание всех функций стандартной библиотеки

[TODO: нумерация сбросилась почему-то]
#show table.cell: c => {
    return align(left + top, text(12pt, c, hyphenate: true))
}
#show figure: set block(breakable: true)
#figure(
  caption: "Перечень функций стандартной библиотеки"
)[
#table(
  columns: (auto, auto, auto),
  table.header(
    "Функция", "Аргументы", "Описание"
  ),
  "Detect", [
    _expression: any_ — выражение для выявления заражённых данных; #linebreak() _vulnerabilityType: string_ — тип уязвимости; #linebreak()
    _grammar: string_ — синтаксический признак данных.
  ],
  "Запускает обнаружение заражённых данных в выражении. В случае, если они будут обнаружены, анализатор вернёт уязвимость соответствующего типа. Грамматика определяет синтаксический тип данных, такой как URL, HTML текст, SQL.",
  "WithTaintMark<T>", [
    _expression: any_ — выражение для добавления taint-метки; #linebreak()
    _taintOrigin_ — тип источника данных.
  ],
  "Добавляет taint-метку к копии выражения.",
  "CreateTaintedDataOfType<T>", [
    _T_ — тип создаваемого объекта; #linebreak()
    _taintOrigin_ — тип источника данных.
  ],
  "Создаёт непроинициализированный объект нужного типа без вызова конструктора и с taint-меткой.",
  "CreateDataOfType<T>", [
    _T_ — тип создаваемого объекта.
  ], 
  "Создаёт объект нужного типа без вызова конструктора без taint-метки.",
  "WithoutVulnerability<T>", [
    _expression: T_ — выражение; #linebreak()
    _vulnerabilityType: string_ — тип уязвимости для фильтрации.
  ],
  "Добавляет отметку об отфильтровывании уязвимости.",
  "GetTaintOrigin", [
    _expression: any_ — выражение.
  ],
  "Возвращает источник taint-данных в виде строки.",
  "As<T>", [
    _expression: any_ — выражение.
  ],
  [Приводит небезопасно выражение к типу _T_.]
)
] <standard-lib-table>

#show figure: set block(breakable: false)


=== Система типов

Система типов разрабатываемого языка проста. Это связано с требованиями, предъявленными к решаемой задаче. Представлено несколько встроенных типов, а также произвольное количество пользовательских типов, порождённых объектами из описаний. В свою очередь, встроенные типы разделяются на основные и на типы, добавленные специально для поддержки определенного языкового модуля PT JSA. Таблица @built-in-types содержит перечень всех встроенных типов. Отношение типизации, используемое для них, представлено на Рисунке @types-hierarchy.

#figure(
  caption: "Встроенные типы",
  table(
    columns: 2*(auto,),
    table.header("Имя типа", "Описание"),
    table.cell(colspan: 2, "Основные типы", align: center),
    [_any_], [Высший (_top_) тип. Является базовым для любого другого типа],
    [_int_], [Тип целого знакового числа. В текущей реализации 64 разряда],
    [_string_], [Строковой тип],
    [_bool_], [Логический тип],
    [_float_], [Тип числа с плавающей точкой. В текущей реализации 64 разряда, IEEE 754],
    [_none_], [Возвращаемый тип функции, не возвращающей ничего, единичный (_unit_) тип],
    table.cell(colspan: 2, "Типы для поддержки Python", align: center),
    [_bytes_], [Тип строки байт],
    [_dict_], [Тип ассоциативного массива],
    [_list_], [Тип списка],
  )
) <built-in-types>

#figure(
  caption: "Иерархия встроенных типов",
  kind: "image",
  supplement: "Рисунок",
  raw-render(
   ```dot
   digraph {
     any -> int
     any -> string
     any -> bool
     any -> float
     any -> none
     any -> bytes
     any -> dict
     any -> list
   }
   ```,
   width: 30em,
  )
)<types-hierarchy>

Пользовательские типы являются подтипом `any` и не могут расширить правила типизации. В случаях, когда в описываемой библиотеке используется подтипирования, можно воспользоваться, по сути, структурной типизацией объектов, которая применяется в PT JSA. Таким образом, необходимо продублировать часть кода, а также использовать приведение типов. В дальнейшем планируется реализовать механизм подтипирования для объектов.

== Разработка транслятора

Данный раздел содержит описание основных технических решений, которые были приняты при разработке транслятора с разработанного DSL в код расширений базы знаний анализатора кода PT JSA на языке C\# Script. 

[TODO: добавить ссылку на исходники]

=== Архитектура транслятора

Упрощённая логическая схема проекта приведена на Рисунке @architecture. _Модуль интерфейса командной строки_ позволяет конфигурировать транслятор, передавая исходные файлы на DSL, C\# Script, а также указывая путь до директории с результирующим кодом. _Ядро транслятора_ выступает посредником между другими модулями. _Модуль построения внутреннего представления_ (_IR_) строит внутреннее представление с помощью лексера и парсера, которые генерируются автоматически при помощи antlr. _Модуль семантического анализа_ ответственен за трансформацию внутреннего представления, а также за проверку типов и прочие проверки. _Транслятор IR->CGIR_ конвертирует внутреннее представление, полученное на этапе семантического анализа в специальное представление, пригодное для генерации кода (_CGIR_). _Модуль синтеза_ генерирует код на языке C\# Script из _CGIR_. 

#figure(
  caption: "Логическая архитектурная схема",
  image("../diagrams/jsa dsl architecture.svg", width: 90%),
) <architecture>

=== Синтаксический анализ

Модуль построения внутреннего представления использует парсер и лексер для получения конкретного синтаксического дерева (_CST, concrete syntax tree_). Они генерируются автоматически при помощи инструмента antlr @antlr4. В качестве входных данных он принимает описания синтаксиса DSL на специализированном языке и порождает код лексера и парсера. 

Стадия синтаксического анализа транслирует конкретное синтаксическое дерево во внутреннее представление, используемое анализатором. Это необходимо так как затруднительно расширить CST.

Для трансляции применяется два класса, реализующие шаблон "посетитель". Они наследуются от класса-посетителя, сгенерированного antlr. Первый необходим для обхода и конвертации представления выражений. Второй — для объявлений и определений, его фрагмент приведён в Листинге @sample-branches. Он создаёт экземпляр класса `IfStatementAstNode`, который содержит информацию об условии ветвления и альтернативную ветку.

#show figure: set block(breakable: true)
#figure(
  caption: "Фрагмент класса-посетителя для обработки ветвлений"
)[
```csharp
public override IStatementAstNode VisitIfStatement(
  JSADSLParser.IfStatementContext context)
  {
    var cond = VisitExpression(context.cond);
    var mainBlockContext = new IrContext(irContext);
    var mainBlockVisitor = new BaseBuilderVisitor(
      mainBlockContext);

    var mainBlock = mainBlockVisitor.VisitStatementsBlock(
      context.mainBlock);
    IStatementAstNode? elseBranch = null;

    if (context.elseIfStatement != null)
    {
      var newContext = new IrContext(irContext);
      var newVisitor = new BaseBuilderVisitor(newContext);

      elseBranch = newVisitor.VisitIfStatement(
        context.elseIfStatement);
    } else if (context.elseBlock != null)
    {
      var newContext = new IrContext(irContext);
      var newVisitor = new BaseBuilderVisitor(newContext);

      elseBranch = newVisitor.VisitStatementsBlock(
        context.elseBlock);
    }

    var ifStatementAstNode = new IfStatementAstNode(
      cond, mainBlock, elseBranch);

    mainBlock.Parent = ifStatementAstNode;
    if (elseBranch != null)
    {
      elseBranch.Parent = ifStatementAstNode;
    }

    return ifStatementAstNode;
  }
```
]<sample-branches>

=== Семантический анализ 

Семантический анализ анализирует и преобразует внутреннее представление, полученное на этапе синтаксического анализа. 

Семантический анализ использует классы, описывающие внутреннее представление. Основные из них приведены в Таблице @ir-classes. В ней колонка "тип" описывает роль соответствующего узла. Узел может быть объявлением, выражением, операцией или иметь другой тип. Колонка "Владение контекстом" обозначает, задаёт ли соответствующий узел свой контекст. 

Контексты используются при разрешении ссылок и позволяют (при отсутствии синтаксических ограничений) создавать новые определения. Контексты образуют иерархию: существует корневой контекст файла, в котором может быть несколько дочерних контекстов для объектов, в каждом из которых может быть произвольное число контекстов функций и так далее. У корневых контекстов есть ссылки на контексты файлов, импортируемые в текущем. Таким образом, сущности в файле могут ссылаться на другие, определённые в подключенных к нему. 

#figure(
  caption: "Основные классы внутреннего представления"
)[
  #table(
    columns: 4*(auto,),
    table.header("Имя", "Тип", [Владение #linebreak() контекстом], "Описание"),
    [_FileAstNode_], "-", "Да", "Хранит имя пакета, а также список объявлений верхнего уровня.",
    [_FunctionAstNode_], "Объявление", "Да", "Хранит имя, список аргументов, тело и прочую информацию о функции.",
    [_IntrinsicFunctionAstNode_], "Объявление", "Нет", "Хранит имя и список аргументов, а также типовые параметры для внутренней функции.",
    [_ObjectAstNode_], "Объявление", "Да", "Хранит имя, объявление полей и функций объекта.",
    [_VarDeclAstNode_], "Объявление", "Нет", "Хранит имя, ссылку на тип и инициализирующее значение переменной.",
    [_BinaryExpressionAstNode_], "Выражение", "Нет", "Хранит операцию и операнды бинарного выражения.",
    [_UnaryExpressionAstNode_], "Выражение", "Нет", "Хранит операцию и операнд унарного выражения.",
    [_FunctionCallAstNode_], [Выражение, #linebreak() операция], "Нет", 
    "Хранит ссылку на вызываемую функцию и список выражений-аргументов.",
    [_IntrinsicFuncInvocationAstNode_], [Выражение, #linebreak() операция], "Нет", 
    "Описывает обычный вызов функции на целевом языке и хранит её имя, ресивер и набор аргументов.",
    [
      _IntLiteralAstNode_, #linebreak()
      _FloatLiteralAstNode_, #linebreak()
      _StringLiteralAstNode_, #linebreak()
      _BoolLiteralAstNode_,
    ], "Выражение", "Нет", "Хранят значение литерала соответствующего типа.",
    [_NewAstNode_], "Выражение", "Нет", "Хранит ссылку на тип инстанциируемого объекта и список аргументов-выражений.",
    [_VarExpressionAstNode_], "Выражение", "Нет", "Хранит ссылку на переменную для выражения.",
    [_AssignmentAstNode_], "Операция", "Нет", "Хранит ресивер и новое значение.",
    [_IfStatementAstNode_], "Операция", "Нет", "Хранит условие, блок главной ветки и альтернативную операцию или ветку.",
    [_StatementsBlockAstNode_], "-", "Да", "Блок-контейнер для операций.",
    [_ReturnStatement_], "Операция", "Нет", "Хранит опциональное возвращаемое из функции значение.",
    [_ImportAstNode_], "Операция", "Нет", "Подключает другой пакет к текущему файлу."
  )
] <ir-classes>

Основным этапом является этап трансформаций. В ней итеративно применяется набор правил переписывания внутреннего представления. Примерами являются упрощение синтаксического сахара @syntax-sugar и частичная замена синтаксических конструкций на вызовы низкоуровневого API JSA. Основные трансформации:

- *Трансформация инициализирующего метода*
  
  Модуль PT JSA, ответственный за анализ кода на Python, учитывает конструкторы классов, которые должны называться `__init__`. Для обеспечения возможности описания конструкторов, а также инициализирующих значений полей объектов, транслятор использует этот механизм. Для полей объектов с инициализирующими значениями генерируется код для их вычисления и присвоения, который вставляется в функцию с именем `__init__`, объявленную в объекте. Если она отсутствует, то функция с таким именем будет синтезирована этой стадией

- *Трансформация ссылок*

  Для обеспечения возможности предварительного определения (_forward declaration_), в трансляторе применяется механизм ссылок. Каждая из ссылок привязана к своему контексту и по ней можно получить ссылаемый объект, если он доступен из соответствующего контекста.  На этом трансформации фактического изменения IR не происходит, однако, оно обходится и для каждой ссылки происходит её запечатывание: если её разрешение происходит успешно, то разрешённая сущность сохраняется в специальное поле внутри ссылки и каждое следующее разрешение будет возвращаться одно и то же значение. Если разрешение не удалось, то это говорит о некорректной программе и возбуждается ошибка. 

- *Трансформатор ветвлений*

  Данное переписывание изменяет внутреннее представление, заменяя узлы ветвлений на использование соответствующего низкоуровневого API анализатора. Использование ветвлений языка C\# Script невозможно, так как значение условия является символьным значением, конкретное значение которого определяется анализатором в момент детектирования уязвимостей. 
  
  PT JSA предоставляет большой набор методов для поддержки ветвлений. Основными из них являются _TryEnterBranch_, принимающий условие попадания в ветку, а также _LeaveBranch_. Они оба принимают специальный идентификатор ветки и сигнализируют о входе и выходе из неё анализатору. При входе в ветку PT JSA автоматически управляет символьным состоянием, добавляя соответствующее условию символьное выражение в текущие ограничения. 

  Таким образом, после этой трансформации код становится линейным с синтаксической точки зрения, но не с семантической

- *Трансформация операций возврата значения из функции*

  В PT JSA каждый из обработчиков описываемой функции возвращает символьное значение в специальной обёртке. Возврат осуществляется при помощи оператора `return` языка C\# Script. Для возможности раннего возврата из ветвления анализатор предоставляет низкоуровневый API. Он использует так называемые кондиционалы, которые можно представить как пары _(текущие ограничения из условий ветвлений; возвращаемое значение)_. API позволяет автоматически получать текущие ограничения, передавая только возвращаемое значение. Так как сам кондиционал является символьным выражением, анализатор поддерживает его возврат из функции-обработчика, что и происходит после применения этого переписывания.

- *Трансформация вызовов функций*

  Вызов обычных функций происходит при помощи API анализатора и так как соответствующий код требует указания обработчика вызываемой функции, его генерация происходит на этапе кодогенерации. 

  Отдельно обрабатываются вызовы внутренних функций. Так как они не являются частью описываемой библиотеки, их вызов происходит напрямую, как вызов обычной функции языка C\# Script. Для этого трансформация заменяет узел внутреннего представления _FunctionCallAstNode_ на _IntrinsicFunctionInvocationAstNode_, что позволяет учесть это различие в поведении при кодогенерации. Дополнительно, по соглашению, это переписывание добавляет аргумент типа `Location`.


Семантические проверки — ключевой этап разработки любого транспилятора. Они позволяют отлавливать ошибки, которые программист допустил при написании кода. Такие дефекты могут быть связаны с типизацией. Этому классу ошибок уделено отдельное внимание. Однако, в коде могут присутствовать и другие. К примеру, использование ещё не объявленной переменной и вызов несуществующей функции.

Для их обнаружения, а также для проверки и вывода отсутствующих типов реализована отдельная подсистема. Она включает в себя абстрактный класс _AbstractCheckerBase_ с единственным методом _Check()_, а также его наследника класс-посетитель _AbstractChecker\<TR\>_, который позволяет обходить всё внутреннее представление программы.

В Листинге @listing-typechecker представлен фрагмент кода, проверяющего типы. Метод _CheckBinArithmeticExpression_ вызывается для каждого узла бинарного выражения. Аргументы _left_ и _right_ содержат левую и правую его часть. В начале метод определяет типы операндов. В случае если возвращаемое значение _CheckExpression_ является нулевым указателем, весь метод также возвращает его. Возвращение нулевого указателя показывает, что на анализируемом выражении произошла ошибка, а значит, его дальнейшую обработку можно пропустить. Затем, метод проверяет, что типы операндов совпадают. Так как в языке нет неявного приведения типов, это поведение корректно. Далее, метод проверяет, что типы операндов являются числовыми. Это следует из семантики языка. Если все проверки выполнены успешно, возвращается тип всего выражения, равный типу любого из аргумента. 

#figure(
  caption: "Фрагмент проверки типов бинарного выражения",
  ```csharp
  private AstType? CheckBinArithmeticExpression(
    IExpressionAstNode left, 
    IExpressionAstNode right)
    {
      var leftType = CheckExpression(left);
      if (leftType == null) {
        return null;
      }

      var rightType = CheckExpression(right);
      if (rightType == null) {
        return null;
      }
      
      if (!CheckTypes(leftType, rightType))
      {
        errorManager.Report(
          Error.TypeMismatch(leftType, rightType));
        return null;
      }

      if (!_numericTypes.Contains(leftType))
      {
        errorManager.Report(
          Error.NumericTypeExpected(leftType));
      }

      if (!_numericTypes.Contains(rightType))
      {
        errorManager.Report(
          Error.NumericTypeExpected(leftType));
      }

      return rightType;
    }
  ```
)<listing-typechecker>

Аналогичным образом происходит проверка всех остальных типов. Отдельно учитываются случаи, когда тип не указан в коде. В этом случае происходит вывод типов с последующим его сохранением. Таким образом решается задача расстановки отсутствующих типов для последующего анализа и кодогенерации. 

Так как предполагается будущее расширение DSL для описания библиотек на различных языках, в которых семантика различается, представлены специальные проверки, зависимые от конкретного языка. Для Python реализована проверка сигнатуры функции _\_\_init\_\__, если она представлена. Проверяется что её возвращаемый тип либо отсутствует, либо совпадает с именем объекта, в котором она написана. Это совпадает с семантикой Python. Проверяется отсутствие оператора _return_ в этом конструкторе. 

=== Генерация целевого кода

Процесс генерации кода начинается с конвертации внутреннего представления _IR_ в специализированное внутреннее представление _CGIR_. Это представление было реализовано специально для проекта за неимением существующих для генерации кода на C\# Script. Представлено большое количество библиотек для генерации обычного кода на C\#, однако, C\# Script является его надмножеством. К примеру, он допускает декларации из тел методов на верхнем уровне, что активно используется для расширения PT JSA. В отличие от IR, _CGIR_ не является сильно-типизированным что упрощает процесс конвертации. Также, оно приближено к синтаксису и семантики целевого языка. 

Для перевода _IR_ в _CGIR_ используется шаблон посетитель. Внутреннее представление семантического анализа обходится и порождается новое, пригодное для генерации. Фрагмент кода для генерации ветвлений приведён в Листинге @listing-translator. В нём сначала генерируется _CGIR_ для выражения условия. Затем, происходит размещение нового контейнера для операций в текущий контекст. Это сделано для упрощения порождения _CGIR_. Каждая из функций конвертера просто помещает очередной оператор в текущий контейнер. После помещения нового контейнера для основной ветки, происходит генерация её тела, а затем, в зависимости от типа альтернативной ветки. Если это другой оператор ветвления, то происходит рекурсивный вызов, результат которого сохраняется в новое представление. В случае если там располагается блок кода, то происходит его кодогенерация. В самом конце, метод возвращает результат конвертации.  

#figure(
  caption: "Фрагмент конвертации ветвления в CGIR",
  ```csharp
  private CgIfElseStatement AsIfStatement(
    IfStatementAstNode node)
    {
      var cond = _expressionsEmitter.EmitExpression(
        node.Cond);
      var ifStatement = new CgIfElseStatement(cond);

      ctx.PushContainer(ifStatement.MainBody);
      EmitStatementBlockAstNode(node.MainBlock);
      ctx.PopContainer();

      if (ifStatement.Elseif != null)
      {
        switch (node.ElseStatement)
        {
          case IfStatementAstNode elseIf:
            ifStatement.Elseif = AsIfStatement(elseIf);
            break;
          case StatementsBlockAstNode elseBlock:
            ifStatement.ElseBody = new CgStatementsContainer();
            ctx.PushContainer(ifStatement.ElseBody);
            EmitStatementBlockAstNode(elseBlock);
            ctx.PopContainer();
            break;
          default:
            throw new ArgumentOutOfRangeException(
              nameof(node.ElseStatement));
            }
        }

        return ifStatement;
    }
  ```
) <listing-translator>

После конвертации происходит порождение кода на языке C\# Script по _CGIR_. Это происходит путём обхода этого представления. Фрагмент генерации текста приведён в Листинге @codegen-listing. Метод _SynthNewExpression_ предназначен для генерации оператора _new_. Стоит заметить, что этот оператор совершенно не совпадает по семантике с одноимённым на DSL, однако, он активно используется в целевом коде. Методы _Append_ и _AppendSpace_ являются вспомогательными и, по своей сути, добавляют соответствующие символы во внутренний _StringBuilder_. Поддерживается автоматическое расстановка отступов блока кода при необходимости, что немного улучшает читаемость генерируемого кода. 

#figure(
  caption: "Фрагмент генерации целевого кода",
  ```csharp
  private void SynthNewExpression(
    CgNewExpression cgNewExpression)
  {
    Append("new");
    AppendSpace();
    Append(cgNewExpression.TypeName);
    Append("(");
    var argsDropLast = cgNewExpression.Args.SkipLast(1);
    foreach (var cgExpression in argsDropLast)
    {
      SynthExpression(cgExpression);
      Append(", ");
    }

    var lastArg = cgNewExpression.Args.LastOrDefault();
    if (lastArg != null)
    {
      SynthExpression(lastArg);
    }

    Append(")");
    }
  ```
) <codegen-listing>

После генерации целевого кода, работа транслятора завершается. Этот процесс проходят все файлы на DSL, подаваемые на вход. 

== Особенности языка и транслятора для поддержки Python

Как было установлено ранее, в качестве демонстрации было принято решение ограничиться поддержкой написания расширений только для модуля PT JSA для анализа кода на Python. Предполагается дальнейшее развитие проекта, в том числе, для поддержки других языков. Этим продиктованы некоторые технические решения, основным из которых является отделение основной семантики DSL от семантики модуля анализа. 

Одним из примеров такого разделения является описание конструкторов объектов. Так как поведение конструкторов существенно различается у популярных языков программирование, было решено повторить эту семантику без дополнительного синтаксиса DSL. Так, для объявления конструктора необходимо добавить функцию с именем _\_\_init\_\__ и аргументами, которые принимает конструктор описываемого объекта. Это полностью повторяет аналогичную семантику языка Python. 

Другой особенностью, которая была поддержана, но уже в трансляторе, является специализированный низкоуровневый API, предоставляемый PT JSA. В частности, этот API позволяет использовать нетипизированные объекты. Они могут быть порождены, к примеру, функцией _CreateDataOfType\<any\>_. Тип _any_ является специальным и указывает, что либо тип объекта неизвестен, либо он неважен. 

Для реализации будущей интеграции с другими языковыми модулями, были заложены архитектурные основы проекта. Код, специфичный для Python, был вынесен в отдельные классы и инкапсулирован в них. В прочем, для этой цели предполагается значительная переработка кода, написанного в большей степени для демонстрации идеи. 

== Резюме

В данной Главе описан разработанный прототипа DSL с точки зрения его синтаксиса и семантики. Используются различные формализмы, такие как грамматические правила и правила типизации. Приводятся и словесные описания для всех языковых возможностей. Затем, происходит описание разработанного прототипа его транслятора в низкоуровневый код на C\# Script. Демонстрируется его архитектура, а также детали реализации синтаксического и семантического анализа, генерации кода. В заключение приводятся различные решения как в DSL, так и в трансляторе, необходимые для поддержки Python. 