#import "../thesis-base.typ": itmo-bachelor-thesis, structural-element, chapter, term

#structural-element("Введение")

Программная инженерия на протяжении всего своего существования стремилась автоматизировать каждый из аспектов разработки и сопровождения программного обеспечения. Так появились компиляторы, IDE, анализаторы кода, ассистенты для его написания и многие другие классы инструментов. Многие из них значительно улучшают качество жизни программистов, а значит, делают их продуктивнее.

Одним из ключевых классов инструментов являются анализаторы кода. Они разделаются на статические, которые производят анализ без фактического запуска программы, а также динамические, которые анализируют запущенную программу. Каждый из этих подходов, как и гибридные, нашли своё применение. К примеру, статический анализ кода применяется в компиляторах, а одной из сфер применения динамического анализа является поиск ошибок в ПО.

Анализаторы кода позволяют определять некоторые свойства программ. К ним относятся: оценка качества кода и проверка соблюдения стиля, обнаружение дефектов и неиспользуемого кода, анализ производительности и энергоэффективности. Для каждого из типов анализа применяются различные подходы. Некоторые из них работают с кодом как с обычным текстом, другим же требуется специальное представление программы для большей эффективности. 

Одним из типов анализа кода является символьное исполнение. Оно производит интерпретацию программы, но, в отличие от обычного (конкретного) исполнения, некоторые из значений, которыми оперирует интерпретатор, могут являться специальные символьные значения. Существует несколько вариаций символьного исполнения: статическое, динамическое и гибридное. Они применяются для решения большого числа задач, таких как автоматическая тестов и поиск ошибок ПО. 

Ещё одним видом статического анализа является абстрактная интерпретация. В отличие от символьного исполнения, которое работает с доменом значений (конкретных или символьных), при абстрактной интерпретации происходит аппроксимация некоторых свойств программы на абстрактный домен (к примеру, домен интервалов численных значений, знаков или типов). Этот метод анализа применяется, в первую очередь, для поиска ошибок и верификации ПО @abstract_interpretation. Можно считать абстрактную интерпретацию обобщением символьного исполнения. Таким образом, при некоторых условиях анализатор, реализующий подход абстрактной интерпретации, может осуществлять символьное исполнение.

Как и у многих других автоматических методов анализа кода, у символьного исполнения и абстрактной интерпретации есть множество технических проблем. Одной из них является проблема взрыва количества путей @path_explotion. Современные программы имеют большие размеры. В большинстве из них представлено большой количество ветвлений, циклов и рекурсий. Для сохранения точности, алгоритмы, реализующие подходы абстрактной интерпретации и символьного исполнения, должны сохранять их и иметь возможность оперировать ими. Так как каждая операция ветвления пути исполнения потенциально приводит к увеличению числа состояний в два раза, эту проблему называют проблемой взрыва количества путей или просто проблемой взрыва путей. 

Существует большое количество подходов для частичного решения проблемы взрыва количества путей. К ним относятся использование суммаризаций, объединяющих несколько состояний в одно, применение эффективных алгоритмов для хранения и операций с состояниями, а также аппроксимацией свойств известного анализируемого кода. К такому коду может относиться код стандартной библиотеки анализируемого языка, код наиболее популярных библиотек и фреймворков. Информация, которую инструмент анализа кода имеет о таких компонентах, называют базой знаний. 

Одной из областей применения абстрактной интерпретации является поиск уязвимостей в исходном коде программ ($"SAST"$, $"static automatic security testing"$). В ней анализаторы отслеживают потоки данных от точек входа ($"sources"$) до стоков ($"sinks"$). В качестве точек входа обычно считают обработчики HTTP-запросов, входные аргументы консольных приложений. Стоками называют базы данных, ответ пользователю, записи на диске. Существуют также фильтрующие функции ($"filters"$), которые проводят валидацию данных из точек входа, предотвращая попадания заражённых ($"tainted"$) данных в стоки. Примером такой валидации могут служить функции, экранирующие HTML-теги, проверяющие пользовательские данные при помощи регулярных выражений и другие преобразования. 

Одним из ведущих SAST анализаторов, использующих абстрактную интерпретацию, является коммерческий анализатор JSA компании Positive Technologies. Он поддерживает анализ таких языков как C\#, Java, JavaScript, TypeScript, Python, PHP и Go. Для каждого из поддерживаемых языков реализован отдельный модуль, называемый языковым провайдером. Языковые провайдеры анализируют исходный код приложений, строят символьное представление, по которому происходит аппроксимация свойства заражённости данных между источниками и стоками. 

PT JSA использует базы знаний об аппроксимациях библиотек и фреймворков на языке сценариев C\# Script — расширении языка C\#. Такие сценарии имеют доступ ко внутренней инфраструктуре анализатора JSA, что даёт неограниченные возможности, однако, требует высоких навыков разработки у программистов. Применение более простого подхода к расширению базы знаний анализатора кода JSA позволило бы упростить этот процесс, что повлекло бы к улучшению таких важных характеристик, как скорость анализа и его точность, у пользователей.

TODO [подправлю когда всё будет готово]: 
В первом разделе приведён обзор существующих подходов к расширению функциональности taint-анализаторов кода. Во втором разделе производится постановка задачи и анализ путей её решения. В третьем разделе описан процесс проектирования прототипа предметно-ориентированного языка и его транслятора в язык C\# Script. В четвёртом разделе описана реализация транслятора. В пятом разделе происходит апробация полученного языка и его транслятора, а также приводятся примеры описаний библиотек на нём. В заключении полученные результаты анализируются, на основании чего приводятся идеи для дальнейшего развития проекта. 