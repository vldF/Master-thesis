#import "../thesis-base.typ": itmo-bachelor-thesis, structural-element, chapter, term
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *

#show: codly-init.with()
#codly(languages: codly-languages, breakable: true)

#chapter(2, "Постановка задачи разработки DSL для расширения базы знаний JSA и анализ путей решения")

== Постановка задачи

Пример типичного кода обработчика запросов в web-сервере с использованием библиотеки Flask и языка программирования Python приведён в Листинге @sqli-example. В нём обработчик запросов _handler_ получает от клиента значение параметра _username_, инициализирует подключение к базе данных и отправляет запрос на получение пользователя с заданным именем из БД. Так как запрос получается простой конкатенацией, а проверок _userid_ в коде нет, этот код уязвим к атаке "внедрение SQL-кода". К примеру, если клиент отправит запрос с аргументом _username_ вида "' OR '1' = '1", то при конкатенации строки запроса подставится дополнительное условие для оператора _SELECT_, которое позволит получить список всех пользователей. 

#show figure: set block(breakable: false)
#figure(
  caption: "Пример обработчика HTTP-запросов с уязвимостью",
  ```python
  app = Flask(__name__)
  
  @app.route('/search_user', methods=['GET'])
  def handler():
    username = request.args.get('username')
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()

    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)

    results = cursor.fetch()

    cursor.close()
    conn.close()

    return jsonify({'user': results})
  ```
)<sqli-example>
#show figure: set block(breakable: true)

Код в Листинге @sqli-example позволяет продемонстрировать taint-анализ. С точки зрения анализа потока данных, источником заражённой информации является поле _args_ объекта _request_. Это ассоциативный массив, содержащий параметры HTTP-запроса, которые передал клиент. Из него извлекается значение с именем _username_. Затем, эти данные подставляются в SQL запрос на строке 9. В зависимости от семантики интерполяции строк, на это можно смотреть по-разному. В Python интерполируемое значение никак не экранируется. Таким образом, метка заражённости данных сохраняется для всего выражения переменной _query_. Затем, она передаётся в функцию _execute_, которая отправляет этот запрос в базу данных. Библиотека для операций с БД не может определить, намеренно запрос был написан так или нет. По этому, запрос передаётся базе данных. Функция _execute_ с точки зрения taint-анализа рассматривается как сток данных, однако, анализ можно продолжить и определить, что вызов функции _fetch_ на 12 строке возвращает данные из БД, полученные уязвимым запросом, а затем его результат передаётся пользователю. 

Автоматически невозможно определить семантику вызовов функции с точки зрения taint-анализа. Информация о них содержится в базе знаний анализатора. Процесс расширения базы знаний сложен из-за необходимости компетенций не только программиста, но и аналитика информационной безопасности. В PT JSA написание кода расширений нетривиально, так как предполагает понимание внутренних механизмов анализатора. В рамках Работы предлагается необходимо упростить процесс написания кода расширений за счёт разработки предметно-ориентированного языка (_DSL_, _domain specific language_), который будет простым и выразительным.

Таким образом, необходимо разработать синтаксис и семантику прототипа DSL и интегрировать его в анализатор JSA. Он должен соответствовать следующим требованиям:

- Пригодность к использованию программистом;
- Способность описывать внешние библиотеки и фреймворки с точки зрения семантики и потоков данных;
- Возможность для переиспользования кода;
- Совместимость с PT JSA;
- Абстрагирование от внутренних особенностей JSA.

== Выбор путей решения

В данном разделе рассматриваются пути реализации языка, а также его интеграции с анализатором JSA компании Positive Technologies.

=== Пригодность к использованию программистом

Существует множество способов описания компонентов. У каждого из них есть преимущества и недостатки, приведённые в Таблице @approaches-compare.

#figure(
  caption: "Сравнение способов описания компонентов ПО",
table(
  columns: (auto, auto, auto, auto, auto, auto),
  table.header(
    "Способ", "Инструменты разработки", "Гибкость описания", "Сложность обучения", "Сложность интеграции с JSA", "Прочее"
  ),
  "На основе YAML, XML, JSON", "существуют, но не предназначены для этого", "низкая", "средняя", "средняя", [--],
  
  "Графически", "существуют, но не предназначены для этого", "низкая", "низкая", "средняя", [--], 
  
  "На существующем языке моделирования ПО", "существуют", "высокая", "зависит от языка", "высокая", "необходимость переработки части языковых возможностей",

  "На языке общего назначения", "существуют", "высокая", "средняя", "средняя", "возможность написания кода, который будет замедлять анализ, необходимость разработки библиотеки для моделирования",
  
  "Разработка нового предметно-ориентированного языка", "отсутствуют", "высокая", "низкая", "низкая", "высокая гибкость принятия любых решений"
)
) <approaches-compare>


Несмотря на высокую сложность реализации, последний способ представляет наибольший интерес. В этом случае разрабатываемый язык должен быть пригодным для разработчика средней квалификации. Это накладывает ограничение на концепции, которые могут быть использованы. Предлагается использовать следующие идеи:

- Статическая типизация:
  - Номинативная типизация;
  - Типовые параметры;
  - Простой вывод типов.
- Использование идей из популярных языков:
  - Объекты;
  - Функции или методы;
  - Переменные;
  - Операции должны иметь очевидный синтаксис.

=== Способность описывать внешние библиотеки и фреймворки с точки зрения семантики и потоков данных

Так как статический анализатор кода PT JSA применяет техники символьного исполнения, абстрактной интерпретации и анализа потока данных, необходимы языковые возможности для описания не только потоков заражённых данных, но и поведения описываемых компонентов.

Необходимо учесть возможности для:

- Описания сигнатур сущностей (методов, объектов, глобальных переменных и т.д.) для возможности сопоставления с описываемыми;
- Указания типов для полей, аргументов методов, возвращаемых значений, переменных для предоставления этой информации об анализируемом коде для языков с динамической типизацией;
- Описания семантики с помощью арифметических операций, операций над строками, вызовов функций, ветвлений, сохранения и чтения из полей объектов;
- Работы с потоками заражённых данных (создание, продвижение, стоки и удаление метки заражённости).

=== Возможность для переиспользования кода

В современной разработке программного обеспечения вопрос переиспользования кода чрезвычайно важен. Механизмы повторного использования кода могут включать:

- Возможность организации модулей;
- Объекты, методы, функции;
- Наследование;
- Метапрограммирование (декораторы, аннотации, макросы, генерация кода).

Переиспользование кода открывает возможности для создания стандартной библиотеки языка. Так, можно перенести часть функциональных возможностей в неё, а не разрабатывать для неё новый синтаксис и семантику. 

=== Совместимость с PT JSA

Так как основной целью проекта является расширение функциональных возможностей анализатора кода PT JSA, обеспечение первоклассной интеграции инструментов является важной задачей. Существует несколько способов её решения:

- Поддержка DSL со стороны JSA.

  Так как поддерживаемые в PT JSA языки имеют особенности, для каждого из них разработан так называемый языковой модуль, который отвечает за статический анализ кода. Таким образом, необходимо поддержать DSL в каждом из модулей, что может оказаться затруднительным.

- Трансляция DSL в поддерживаемый JSA язык.

  Этот подход позволит разработать DSL без модификации PT JSA. Однако, для реализации этого подхода потребуется реализация и поддержка транслятора для каждого из поддерживаемых языков (на момент написания работы их 7).

- Трансляция DSL в язык C\# Script с использованием существующего API расширений.

  Данный подход предлагает преимущество предыдущего, а именно, отсутствие модификации PT JSA. И также он ликвидирует его недостаток с необходимостью поддержки языка в каждом из модулей. Ещё одним преимуществом данного подхода является совместимость с расширениями базы знаний на C\# Script. Можно организовать двустороннее использование кода между DSL и старым кодом, реализовывать особенно сложные случаи описания компонентов на C\# Script, а также разработать на нём часть стандартной библиотеки. 

  
Последний подход представляет наибольший интерес ввиду своей гибкости, а также возможности интеграции с уже существующей базой знаний.


== Абстрагирование от внутренних особенностей PT JSA

Низкоуровенвый API уже доступен из расширений базы знаний на языке C\# Script и используется для внутренних нужд. Низкий уровень абстрагирования от деталей реализации анализатора делает практически невозможным его использование программистами, далёкими от них. В Листинге @lib-example приведён фрагмент примера описываемой библиотеки на языке Python. Листинг @lib-usage-example содержит пример использования этой библиотеки. 

#figure(
```python
class Request:
  def get_param(self, paramname: str) -> None:
    # код получения значения параметра HTTP-запроса по
    # имени; источник заражённых данных
    pass
    
class Response:
  def send(self, text: str) -> None:  # сток
    # код отправки строки пользователю в качестве ответа;
    # сток данных
    pass
    
def handle(
  url: str, 
  handler: Callable[[Request, Response], None]
) -> None:
  # связывание кода обработчика запроса с 
  # соответствующим URL
  pass

def escape_html(text: str) -> str:  # фильтрующая функция
  # возвращает строку text с экранированием HTML-символов;
  # фильтрующая функция
  pass
```,
caption: [Фрагмент пример кода библиотеки.]
) <lib-example>

#figure(
```python
from customModule import handle, escape_html 
import sqlite3

con = sqlite3.connect("foo@bar.baz")
def vulnerable_handler(request, response):
  param = request.get_param("baz")
  response.send(param)  # межсайтовый скриптинг (XSS)

def filtered_handler(request, response):
  param = request.get_param("baz")
  # нет уязвимости из-за фильтрации
  response.send(escape_html(param))

def conditional_handler(request, response):
  condition = request.get_param("is_admin")
  result = None
  if condition == "secret_key":
    query = request.get_param("sql")
    cursor = con.cursor().execute(query) # SQL инъекция
    result = cursor.fetchone()
  response.send(result)
  
handle("/vulnerable", vulnerable_handler)
handle("/filtered", filtered_handler)
handle("/admin", conditional_handler)
```,
caption: [Пример пользовательского кода.]
) <lib-usage-example>

Примитивный фреймворк, описанный в Листинге @lib-example, содержит в себе источник (функция _get_param_ класса _Request_), фильтрующую функцию (_escape_html_) и сток (_send_ класса _Response_). Семантика этих функций отображена в расширении базы знаний, приведённом в Листинге @lib-descr на языке C\# Script.

#show figure: set block(sticky: true)
#figure(
```csharp
var requestclass = PythonTypes.CreateClass("Request")
  .WithMethod("get_param", (location, functionCall) =>
  {
    var nameExpression = functionCall.Arguments[1];
    var taintOrigin = QueryOrigin(nameExpression);
    return ProcessorApi.CreateTaintedString(taintOrigin);
  }

var responseClass = PythonTypes.CreateClass("Response")
  .WithMethod("send", (location, functionCall) =>
  {
    if (functionCall.Arguments.Length > 0) {
      Detector.Detect(
        location, 
        functionCall.Arguments[1],
        VulnerabilityType.CrossSiteScripting, 
        PvoArgumentGrammar.HtmlText);
    }
    return SemanticsApi.None;
  }

CreateModuleFunction("handle", (location, functionCall) =>
  {
    var urlExpression = functionCall.Arguments[0];
    var handlerFunc = functionCall.Arguments[1];
    var request = requestClass.CreateInstance(location);
    var response = responseClass.CreateInstance(location);

    ProcessFrameworkEntryPoint(
      location, 
      urlExpression,
      HttpMethodType.All,
      forkedApi =>
        forkedApi.Interpreter.InvokeFunction(
          location, 
          handlerFunc,
          request,
          response));
          
    return SemanticsApi.None;
  }
);

CreateModuleFunction(
  "escapeHtml", 
  (location, functionCall) =>
  {
    return functionCall
      .Arguments[0]
      .AddFilteredPvoGrammar(PvoArgumentGrammar.HtmlText);
  }
);
```,
caption: [Пример расширения JSA для поддержки библиотеки.]
) <lib-descr>

Можно заметить, что даже для такого простого примера необходимо оперировать большим количеством низкоуровневых операций, таких как обработчик метода (последний аргумент функции _WithMethod_), грамматики (синтаксический тип данных). Количество аргументов вызова функции также необходимо проверять вручную. Значение _Location_ передаётся во многие операции. Это необходимо для точности результатов анализа. Таким образом, проектируемый DSL должен предоставлять абстракции, которые скрывают описанные сложности, что приведёт к упрощению обучения этому языку, а также ускорению написания кода на нём. За счёт уменьшения объёма кода, снизится и количество ошибок.

== Резюме

В этой главе описаны основные свойства, которыми должен обладать разрабатываемый способ расширения базы знаний поддержки библиотек и фреймворков анализатора PT JSA. Ими стали:

- Расширение задаётся с помощью кода на новом предметно-ориентированном языке с простыми и очевидными синтаксисом и семантикой;
- Язык должен быть расширяемым с помощью изменений в стандартной библиотеке;
- В нём должны быть представлены возможности для описания потоков данных и семантики у внешних компонентов;
- Возможность выделения кода в пакеты;

Для ускорения разработки прототипа, были принято решение ограничить возможность разработки расширений только для языка Python с возможностью последующей доработки для поддержки других языков, поддерживаемых PT JSA. 