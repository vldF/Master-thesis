#import "../thesis-base.typ": itmo-bachelor-thesis, structural-element, chapter, term
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *

#show: codly-init.with()
#codly(languages: codly-languages, breakable: true)

#chapter(2, "Постановка задачи разработки DSL для расширения базы знаний PT JSA и анализ путей решения")

== Постановка задачи

Необходимо разработать синтаксис и семантику предметно-ориентированного языка (_DSL_, _domain specific language_) и интегрировать его в анализатор PT JSA. Необходимо реализовать прототип. Он должен соответствовать следующим требованиям:

- Пригодность к использованию программистом;
- Способность описывать внешние библиотеки и фреймворки с точки зрения семантики и потоков данных;
- Возможность для переиспользования кода;
- Совместимость с PT JSA;
- Абстрагирование от внутренних особенностей PT JSA.

== Выбор путей решения

В данном разделе рассматриваются пути реализации языка, а также его интеграции с анализатором PT JSA.

=== Пригодность к использованию программистом

Существует множество способов описания компонентов. У каждого из них есть преимущества и недостатки:
[TODO: оформить по ГОСТу]
#show table.cell: c => {
    return text(12pt, c, hyphenate: true)
}
#table(
  columns: (auto, auto, auto, auto, auto, auto),
  align: horizon,
  table.header(
    "Способ", "Инструменты разработки", "Гибкость описания", "Сложность обучения", "Сложность интеграции с PT JSA", "Прочее"
  ),
  "На основе YAML, XML, JSON", "существуют, но не предназначены для этого", "низкая", "средняя", "средняя", [--],
  
  "Графически", "существуют, но не предназначены для этого", "низкая", "низкая", "средняя", [--], 
  
  "На существующем языке моделирования ПО", "существуют", "высокая", "зависит от языка", "высокая", "необходимость переработки части языковых возможностей",

  "На языке общего назначения", "существуют", "высокая", "средняя", "средняя", "возможность написания кода, который будет замедлять анализ, необходимость разработки библиотеки для моделирования",
  
  "Разработка нового предметно-ориентированного языка", "отсутствуют", "высокая", "низкая", "низкая", "высокая гибкость принятия любых решений"
)

Несмотря на высокую сложность реализации, последний способ представляет наибольший интерес. В этом случае разрабатываемый язык должен быть пригодным для разработчика средней квалификации. Это накладывает ограничение на концепции, которые могут быть использованы. Предлагается использовать следующие идеи:

- Статическая типизация:
  - Номинативная типизация;
  - Типовые параметры;
  - Простой вывод типов.
- Использование идей из популярных языков:
  - Объекты;
  - Функции или методы;
  - Переменные;
  - Операции должны иметь очевидный синтаксис.

=== Способность описывать внешние библиотеки и фреймворки с точки зрения семантики и потоков данных

Так как статический анализатор кода PT JSA применяет техники символьного исполнения, абстрактной интерпретации и анализа потока данных, необходимы языковые возможности для описания не только потоков заражённых данных, но и поведения описываемых компонентов.

Необходимо учесть возможности для:

- Описания сигнатур сущностей (методов, объектов, глобальных переменных и т.д.) для возможности сопоставления с описываемыми;
- Указания типов для полей, аргументов методов, возвращаемых значений, переменных для предоставления этой информации об анализируемом коде для языков с динамической типизацией;
- Описания семантики с помощью арифметических операций, операций над строками, вызовов функций, ветвлений, сохранения и чтения из полей объектов;
- Работы с потоками заражённых данных (создание, продвижение, стоки и удаление метки заражённости).

=== Возможность для переиспользования кода

В современной разработке программного обеспечения вопрос переиспользования кода чрезвычайно важен. Механизмы повторного использования кода могут включать:

- Возможность организации модулей;
- Объекты, методы, функции;
- Наследование;
- Метапрограммирование (декораторы, аннотации, макросы, генерация кода).

Переиспользование кода открывает возможности для создания стандартной библиотеки языка. Так, можно перенести часть функциональных возможностей в неё, а не разрабатывать для неё новый синтаксис и семантику. 

=== Совместимость с PT JSA

Так как основной целью проекта является расширение функциональных возможностей анализатора кода PT JSA, обеспечение первоклассной интеграции инструментов является важной задачей. Существует несколько способов её решения:

- Поддержка DSL со стороны JSA.

  Так как поддерживаемые в PT JSA языки имеют особенности, для каждого из них разработан так называемый языковой модуль, который отвечает за статический анализ кода. Таким образом, необходимо поддержать DSL в каждом из модулей, что может оказаться затруднительным.

- Трансляция DSL в поддерживаемый JSA язык.

  Этот подход позволит разработать DSL без модификации PT JSA. Однако, для реализации этого подхода потребуется реализация и поддержка транслятора для каждого из поддерживаемых языков (на момент написания работы их 7).

- Трансляция DSL в язык C\# Script с использованием существующего API расширений.

  Данный подход предлагает преимущество предыдущего, а именно, отсутствие модификации PT JSA. И также он ликвидирует его недостаток с необходимостью поддержки языка в каждом из модулей. Ещё одним преимуществом данного подхода является совместимость с расширениями базы знаний на C\# Script. Можно организовать двустороннее использование кода между DSL и старым кодом, реализовывать особенно сложные случаи описания компонентов на C\# Script, а также разработать на нём часть стандартной библиотеки. 

  
Последний подход представляет наибольший интерес ввиду своей гибкости, а также возможности интеграции с уже существующей базой знаний.


== Абстрагирование от внутренних особенностей PT JSA

Низкоуровенвый API уже доступен из расширений базы знаний на языке C\# Script и используется для внутренних нужд. Низкий уровень абстрагирования от деталей реализации анализатора делает практически невозможным его использование программистами, далёкими от них. В Листинге @lib-example приведён фрагмент примера описываемой библиотеки на языке Python. Листинг @lib-usage-example содержит пример использования этой библиотеки. 

#figure(
```python
class Request:
  def get_param(self, paramname: str) -> None:
    # код получения значения параметра HTTP запроса по
    # имени; источник заражённых данных
    pass
    
class Response:
  def send(self, text: str) -> None:  # сток
    # код отправки строки пользователю в качестве ответа;
    # сток данных
    pass
    
def handle(
  url: str, 
  handler: Callable[[Request, Response], None]
) -> None:
  # связывание кода обработчика запроса с 
  # соответствующим URL
  pass

def escape_html(text: str) -> str:  # фильтрующая функция
  # возвращает строку text с экранированием HTML-символов;
  # фильтрующая функция
  pass
```,
caption: [Фрагмент пример кода библиотеки.]
) <lib-example>

#figure(
```python
from customModule import handle, escape_html 
import sqlite3

con = sqlite3.connect("foo@bar.baz")
def vulnerable_handler(request, response):
  param = request.get_param("baz")
  response.send(param)  # межсайтовый скриптинг (XSS)

def filtered_handler(request, response):
  param = request.get_param("baz")
  # нет уязвимости из-за фильтрации
  response.send(escape_html(param))

def conditional_handler(request, response):
  condition = request.get_param("is_admin")
  result = None
  if condition == "secret_key":
    query = request.get_param("sql")
    cursor = con.cursor().execute(query) # SQL инъекция
    result = cursor.fetchone()
  response.send(result)
  
handle("/vulnerable", vulnerable_handler)
handle("/filtered", filtered_handler)
handle("/admin", conditional_handler)
```,
caption: [Пример пользовательского кода.]
) <lib-usage-example>

Примитивный фреймворк, описанный в Листинге @lib-example, содержит в себе источник (функция _get_param_ класса _Request_), фильтрующую функцию (_escape_html_) и сток (_send_ класса _Response_). Семантика этих функций отображена в расширении базы знаний, приведённом в Листинге @lib-descr на языке C\# Script.

#figure(
```csharp
var requestclass = PythonTypes.CreateClass("Request")
  .WithMethod("get_param", (location, functionCall) =>
  {
    var nameExpression = functionCall.Arguments[1];
    var taintOrigin = QueryOrigin(nameExpression);
    return ProcessorApi.CreateTaintedString(taintOrigin);
  }

var responseClass = PythonTypes.CreateClass("Response")
  .WithMethod("send", (location, functionCall) =>
  {
    if (functionCall.Arguments.Length > 0) {
      Detector.Detect(
        location, 
        functionCall.Arguments[1],
        VulnerabilityType.CrossSiteScripting, 
        PvoArgumentGrammar.HtmlText);
    }
    return SemanticsApi.None;
  }

CreateModuleFunction("handle", (location, functionCall) =>
  {
    var urlExpression = functionCall.Arguments[0];
    var handlerFunc = functionCall.Arguments[1];
    var request = requestClass.CreateInstance(location);
    var response = responseClass.CreateInstance(location);

    ProcessFrameworkEntryPoint(
      location, 
      urlExpression,
      HttpMethodType.All,
      forkedApi =>
        forkedApi.Interpreter.InvokeFunction(
          location, 
          handlerFunc,
          request,
          response));
          
    return SemanticsApi.None;
  }
);

CreateModuleFunction(
  "escapeHtml", 
  (location, functionCall) =>
  {
    return functionCall
      .Arguments[0]
      .AddFilteredPvoGrammar(PvoArgumentGrammar.HtmlText);
  }
);
```,
caption: [Пример расширения JSA для поддержки библиотеки.]
) <lib-descr>

Можно заметить, что даже для такого простого примера необходимо оперировать большим количеством низкоуровневых операций, таких как обработчик метода (последний аргумент функции _WithMethod_), грамматики (синтаксический тип данных). Количество аргументов вызова функции также необходимо проверять вручную. Значение _Location_ передаётся во многие операции. Это необходимо для точности результатов анализа. Таким образом, проектируемый DSL должен предоставлять абстракции, которые скрывают описанные сложности, что приведёт к упрощению обучения этому языку, а также ускорению написания кода на нём. За счёт уменьшения объёма кода, снизится и количество ошибок.

== Резюме

В этой главе описаны основные свойства, которыми должен обладать разрабатываемый способ расширения базы знаний поддержки библиотек и фреймворков анализатора PT JSA. Ими стали:

- Расширение задаётся с помощью кода на новом предметно-ориентированном языке с простыми и очевидными синтаксисом и семантикой;
- Язык должен быть расширяемым с помощью изменений в стандартной библиотеке;
- В нём должны быть представлены возможности для описания потоков данных и семантики у внешних компонентов;
- Возможность выделения кода в пакеты;

Для ускорения разработки прототипа, были принято решение ограничить возможность разработки расширений только для языка Python.